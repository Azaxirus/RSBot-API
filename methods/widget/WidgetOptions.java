package org.powerbot.game.api.methods.widget;

import java.util.LinkedList;
import java.util.List;

import org.powerbot.game.api.methods.Widgets;
import org.powerbot.game.api.util.Filter;
import org.powerbot.game.api.wrappers.widget.Widget;
import org.powerbot.game.api.wrappers.widget.WidgetChild;
import org.powerbot.game.api.wrappers.widget.WidgetOption;

/**
 * @author Stephan J. Bijzitter (Salvation)
 * @since 26-04-2012
 */
public class WidgetOptions {
	/**
	 * A total of five (5) options can be seen on one parent.
	 * The following numbers are their indices of their option- and number-components respectively:
	 * #1: 03, 12
	 * #2: 24, 25
	 * #3: 29, 30
	 * #4: 34, 35
	 * #5: 39, 40
	 * The number-components are always valid and never visible.
	 * The number-components' getText() returns always the same.
	 * The option-components are always valid and never visible.
	 * The option-components' getText() is empty or null if the option is non-existent.
	 */
	private static final int[][] OPTION_ARRAY = {
			{03, 12},
			{24, 25},
			{29, 30},
			{34, 35},
			{39, 40}
	};

	/**
	 * @return The parent Widget possibly containing WidgetOptions.
	 */
	public static Widget getParentWidget() {
		return Widgets.get(1188);
	}

	/**
	 * @return A list containing all active WidgetOptions.
	 */
	public static List<WidgetOption> getWidgetOptions() {
		final Widget w = getParentWidget();
		final List<WidgetOption> list = new LinkedList<WidgetOption>();

		if (w != null) {
			for (int i = 1; i < 6; i++) {
				final int[] array = OPTION_ARRAY[i - 1];
				final WidgetChild a = w.getChild(array[0]);
				final WidgetChild b = w.getChild(array[1]);

				if (a != null && b != null && a.validate() && b.validate()) {
					final String s = b.getText();

					if (s != null && s.startsWith(Integer.toString(i))) {
						list.add(new WidgetOption(i, a));
						continue;
					}
				}
				break;
			}
		}
		return list;
	}

	/**
	 * @param option A WidgetOption's getText() must partially contains this String to be added to the list.
	 * @return A list of WidgetOptions containing specified option.
	 */
	public static List<WidgetOption> getWidgetOptions(final String option) {
		final List<WidgetOption> list = new LinkedList<WidgetOption>();
		for (final WidgetOption w : getWidgetOptions()) {
			if (w.getWidgetChild().getText().toLowerCase().contains(option.toLowerCase())) {
				list.add(w);
			}
		}
		return list;
	}

	/**
	 * @param filter A Filter which must accept a WidgetOption for it to be added to the list.
	 * @return A list of WidgetOptions accepted by the filter.
	 */
	public static List<WidgetOption> getWidgetOptions(final Filter<WidgetOption> filter) {
		final List<WidgetOption> list = new LinkedList<WidgetOption>();
		for (final WidgetOption w : getWidgetOptions()) {
			if (filter.accept(w)) {
				list.add(w);
			}
		}
		return list;
	}

	/**
	 * @param option The option String to be used by getWidgetOptions(String option).
	 * @return The first instance in the list generated by getWidgetOptions(String option) if existent, otherwise null.
	 */
	public static WidgetOption getWidgetOption(final String option) {
		final List<WidgetOption> list = getWidgetOptions(option);
		return list.isEmpty() ? null : list.get(0);
	}

	/**
	 * @return The first instance in the list generated by getWidgetOptions(Filter<WidgetOption> filter) if existent, otherwise null.
	 */
	public static WidgetOption getWidgetOption(final Filter<WidgetOption> filter) {
		final List<WidgetOption> list = getWidgetOptions(filter);
		return list.isEmpty() ? null : list.get(0);
	}

	/**
	 * @return Widgets.canContinue().
	 */
	public static boolean canContinue() {
		return Widgets.canContinue();
	}

	/**
	 * @return A new instance of the continue option
	 */
	public static WidgetOption getContinueOption() {
		return new WidgetOption(-1, Widgets.getContinue());
	}
}